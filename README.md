# MapTool
https://github.com/inja2001m/DX3D11_TerrainRendering 를 기반으로 제작  

## 조작키
W, A, S, D: 이동  
Q: 상승  
E: 하강  
마우스 우클릭후 드래그: 회전  
←, →, ↑, ↓: 회전  
F1; UI 끄기 켜기  
F2: Wireframe 모드 끄기 켜기  
F3: 상호작용 재생 끄기 켜기  
F4: CellLine 표시 끄기 켜기  
F5: 자유이동 끄기 켜기  

## 개발자 노트
### 2017-03-21
![1](https://cloud.githubusercontent.com/assets/13383741/24149895/65523ba2-0e87-11e7-8fdb-d8cd3a6a69eb.PNG)
1. 프로젝트 생성  
2. 분할 뷰 구현

### 2017-03-22
![1](https://cloud.githubusercontent.com/assets/13383741/24201478/795e088e-0f53-11e7-84a1-77ccb80507f3.PNG)
1. FormView와 DirectX 프레임워크 연결

### 2017-03-28
![1](https://cloud.githubusercontent.com/assets/13383741/24409360/f387d6d8-140a-11e7-978a-8cff1dfa3f6a.PNG)
1. 전체적인 해상도 조절
2. 화면 크기 조절 제거
3. 최소화, 최대화 제거
4. 분할 뷰 크기 조절 제거

### 2017-03-28
![default](https://cloud.githubusercontent.com/assets/13383741/24754747/a828f014-1b12-11e7-92f3-b33c76073cf8.PNG)
1. TerrainRendering 프로젝트 소스 추가

### 2017-04-11
!사진으로 표현할 수 없기 때문에 사진은 없습니다.  
1. 조작키 변경(마우스 시점 변환 구현 등)
2. DirectXView 클래스 삭제 후 MapToolView 클래스 사용

### 2017-04-27
![1](https://cloud.githubusercontent.com/assets/13383741/25487568/937649da-2b9f-11e7-9978-afd31b0a2fc8.PNG)
![2](https://cloud.githubusercontent.com/assets/13383741/25487569/93a05694-2b9f-11e7-879b-9c4b05fe2d2a.PNG)
1. 파일 생성 다이얼로그 UI 업데이트
2. Cell Size와 Tile Size를 선택하여 지형 생성 구현

### 2017-05-30
![1](https://cloud.githubusercontent.com/assets/13383741/26587353/089eb0e2-458d-11e7-9098-aed9a5f13fba.png)
1. 원하는 텍스쳐 파일 선택 후 맵핑 구현  
2. TextureClass 내부 변경  
  
기존에는 LoadTarga()라는 함수가 있었는데 알고보니 이 함수는 fread()함수를 통해  
이미지를 바이너리 형식으로 읽어 형식에 딱 맞는 구조체를 만들고 그 안에 이미지의  
메타데이터들을 담는 것이었다.  
  
하지만 tga 형식이 아닌 다른 형식의 이미지를 읽지는 못 하였기 때문에  
나는 jpg header의 구조를 가진 구조체를 구글링하여 만들었고 fread()함수를 사용해서  
jpg 파일을 읽었지만 이상하게도 정해진 구조에 알맞은 값들이 들어가지 않았다.  
그래서 간단히 D3DX함수를 사용하여 텍스쳐를 읽으려 했지만 나는 윈도우10에 내장된  
DirectX SDK를 사용하고 있고 D3DX함수는 성능상 좋지 않다고 해서 사용하지 않게 되었다.  
  
그렇게 구글링을 하다가 DirectXTex라는 공식 라이브러리를 찾았고 그 라이브러리를 통해  
파일 형식에 맞게 이미지를 읽을 수 있게 되었다.  
  
어떻게 보면 직접 구조체를 선언하여 데이터를 받아오는 것 보다 쉬운 방법일지도 모르지만  
사실 두 경우의 성능 차이가 얼마나 있는지는 자세히 모르기 때문에 어떤 것이  
더 좋다 라고 말하기는 어렵다. 나중에 다시 원래의 방법을 동작하게 해서 DirectXTex를  
사용한 것과 비교해봐야겠다.  

### 2017-08-01
![default](https://user-images.githubusercontent.com/13383741/28827841-d17d5c68-7709-11e7-945b-b208324d6b4a.PNG)  
 현재 기능 구현과 몇몇 버그들 때문에 어려움을 겪고 있어 개발이 더딘 상태이다.  
여러 기능을 구현 중이지만 오늘 고민한 것은 위의 이미지 처럼 파일 생성 할 때   
미리보기로 나오는 이미지중 tga 형식의 이미지는 어떻게 처리해야 하나 였다.  
기존엔 단순히 CImage 클래스를 이용했지만 tga 파일은 지원하지 않았기   
때문에 다른 방법을 찾을 수 밖에 없었다.  
  
몇 가지 해결 방법들을 알아냈지만 각각 어떠한 이유들 때문에 실패했다.  

그 몇 가지 들은
***
>#### CxImage 라이브러리를 사용한다.  
> 어떠한 이유에서인지 이 라이브러리를 사용하면 링킹 오류가 발생한다.  
하지만 오류만 나지 않는다면 가장 간단한 방법이 될 듯 하다.  
***
>#### DirectXTex 라이브러리를 사용한다.  
> 이 라이브러리는 이미 사용하고 있다.  
하지만 텍스쳐를 그리기 위해선 ShaderResourceView를 생성해야 하는데  
이를 생성하는 함수를 사용하려면 ID3D11Device를 파라미터로 주어야한다.  
그러려면 먼저 ID3D11Device를 생성해야 하는데 현재 미리보기를 위한 텍스쳐가  
그려질 윈도우 창은 그 장치가 생성하기 전에 띄워지기 때문에 구현이 까다롭다.  
***
> #### 이미지 파일들을 읽는 함수를 직접 구현하여 사용한다.
> 이 방법은 바로 전 개발자 노트에도 있는 내용이다. 그 때도 구현하려다가 실패했다.  
이미지 파일의 Header에 맞는 형식의 구조체를 만들어 fread함수를 사용해 읽어도  
제대로 읽히지 않을 때도 있었고 그렇게 해서 나온 메타 데이터들을 가지고  
어떻게 사용해야 텍스쳐를 그릴 지 자세히 감이 잡히지 않았다.  
이 방법도 아마 ID3D11Device, ID3D11DeviceContext가 쓰일 것 같다.  
***
아마도 이 방법 중에 첫 번째 방법을 좀 더 생각해봐야 할 듯 싶다.  
  
__+ 새 프로젝트를 만들어서 확인한 결과 32bit 환경에선 오류가 안나고 64bit 에서만 오류가 나는 걸로 보아 이 문제인 것 같다.__

### 2017-08-07
__*NoBug*__
![nobug](https://user-images.githubusercontent.com/13383741/29005766-7271c534-7b1d-11e7-9872-4db1071053ba.PNG)  
__*Bug*__
![bug](https://user-images.githubusercontent.com/13383741/29005767-7271d024-7b1d-11e7-8fbe-2008072925a5.PNG)

이번 커밋에서는 CxImage 라이브러리를 붙이기 전에 먼저  
공용으로 사용하는 헤더 파일과 구조체 등을 선언해 놓은 Defines 헤더를 작성했다.  
  
하지만 기존 클래스 안에 선언해놓은 구조체를 다른 헤더파일에 선언해서 사용했더니  
렌더링이 이상하게 되는 버그가 있었다.   
  
갑작스러운 버그 때문에 하루를 꼬박 삽질했는데 알고 보니 이유가  
그 구조체는 셰이더 단에서 정점의 정보를 담은 구조체로도 쓰였는데  
내가 Defines 헤더에 선언한 구조체의 align과 셰이더 파일에서  
선언한 구조체의 align이 맞지 않아서였다.  
